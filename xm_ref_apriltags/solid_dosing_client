import os
import socket
import logging  # Temporary for simple logger
from pathlib import Path
from time import sleep
# from dotenv import load_dotenv  # Commented out temporarily
# from sdl_utils import get_logger  # Commented out temporarily
# from sdl_utils import connect_socket, send_file_name, receive_file_name, send_file_size, receive_file_size, receive_file  # Commented out temporarily

# ============================================================================
# TEMPORARY REPLACEMENT FUNCTIONS (remove when sdl_utils is working)
# ============================================================================

# Simple logging setup (replacing sdl_utils.get_logger)
def get_logger(name):
    logger = logging.getLogger(name)
    logger.setLevel(logging.INFO)
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
    return logger

# Simple socket connection (replacing sdl_utils.connect_socket)
def connect_socket(sock, host, port, logger):
    try:
        sock.connect((host, port))
        logger.info(f"Connected to {host}:{port}")
        return sock
    except Exception as e:
        logger.error(f"Failed to connect to {host}:{port}: {e}")
        return None

# Simple file transfer functions (matching the server functions)
def send_file_name(conn, filename, logger):
    filename_bytes = filename.encode('utf-8')
    filename_length = len(filename_bytes)
    conn.sendall(filename_length.to_bytes(4, byteorder='big'))
    conn.sendall(filename_bytes)
    logger.info(f"Sent filename: {filename}")

def receive_file_name(conn, logger):
    try:
        length_bytes = conn.recv(4)
        if len(length_bytes) != 4:
            return None
        length = int.from_bytes(length_bytes, byteorder='big')
        filename_bytes = conn.recv(length)
        filename = filename_bytes.decode('utf-8')
        logger.info(f"Received filename: {filename}")
        return filename
    except Exception as e:
        logger.error(f"Error receiving filename: {e}")
        return None

def send_file_size(conn, size, logger):
    size_str = str(size)
    size_bytes = size_str.encode('utf-8')
    size_length = len(size_bytes)
    conn.sendall(size_length.to_bytes(4, byteorder='big'))
    conn.sendall(size_bytes)
    logger.info(f"Sent file size: {size}")

def receive_file_size(conn, logger):
    try:
        length_bytes = conn.recv(4)
        if len(length_bytes) != 4:
            return None
        length = int.from_bytes(length_bytes, byteorder='big')
        size_bytes = conn.recv(length)
        size_str = size_bytes.decode('utf-8')
        logger.info(f"Received file size: {size_str}")
        return int(size_str)  # Return as integer for file operations
    except Exception as e:
        logger.error(f"Error receiving file size: {e}")
        return None

def receive_file(conn, file_size, chunk_size, logger):
    """Receive file data in chunks"""
    received_data = b''
    bytes_received = 0
    
    while bytes_received < file_size:
        remaining = file_size - bytes_received
        recv_size = min(chunk_size, remaining)
        chunk = conn.recv(recv_size)
        if not chunk:
            break
        received_data += chunk
        bytes_received += len(chunk)
        
    logger.info(f"Received {bytes_received}/{file_size} bytes")
    return received_data

# ============================================================================
# END TEMPORARY REPLACEMENT FUNCTIONS
# ============================================================================

# Load environment variables from .env file (commented out temporarily)
# load_dotenv()

# Get settings from environment variables

server_ip = os.getenv ("SERVER_IP", "192.168.1.3")
server_port = int (os.getenv ("SERVER_PORT", 2222))
buffer_size = int (os.getenv ("BUFFER_SIZE", 2048))
chunk_size = int (os.getenv ("CHUNK_SIZE", 1024))
path_tesseract = os.getenv ("PATH_TESSERACT")

# This class implements a client that connects to a server to receive photos
class PhotoClient:
 
    def __init__(self, host = "0.0.0.0", port = server_port, logger = None):
        self.host = host
        self.port = port
        self.server_ip = server_ip
        self.logger = self.setup_logger()

    # Create the logger and file handler
    @staticmethod
    def setup_logger():
        logger = get_logger ("PhotoClientLogger")
        return logger

    # Run this code to update the server IP address the first time you set up the server or when its IP address changes
   
    def update_server_ip (self):
       
        ip_up_to_date = input (f"Is the server IP address: {self.server_ip}? [Y]: ")
        while True:
            if ip_up_to_date in ['', 'y', 'Y', 'yes', 'Yes']:
                break
            elif ip_up_to_date in ['n', 'N', 'No', 'no']:
                new_server_ip = input("What is the new ip address")
                self.logger.info(f"IP address updated to {new_server_ip}")
                self.server_ip = new_server_ip
                break

    # Receives a photo file from the server over a socket connection
    # Saves the photo to the specified directory and returns the path of the saved photo
    def receive_photo (self, sock):
    
        # Create the photos directory if it does not exist already
        output_dir = "Detection_Photos"
        os.makedirs (output_dir, exist_ok = True)
        
        # Receive the image name and echo back to confirm
        img_name = receive_file_name (sock, self.logger)
        self.logger.info (f"Server sent file name {img_name}.")
        send_file_name (sock, img_name, self.logger)
        self.logger.info ("Echoed the file name back to server.")
        img_path = os.path.join (output_dir, img_name)

        # Receive ASCII-based file size and echo back to confirm
        file_size = receive_file_size (sock, self.logger)
        self.logger.info (f"Server sent file size: {file_size} bytes.")
        send_file_size (sock, file_size, self.logger)
        self.logger.info ("Echoed the file size back to server.")

        # Now receive the actual file data in chunks, and write the file to disk
        received_data = receive_file (sock, file_size, chunk_size, self.logger)
        with open (img_path, "wb") as f:
            f.write (received_data)
        self.logger.info (f"File {img_name} saved to: {output_dir}")
        return True, img_path

    def interactive_client_session (self):
        with socket.socket (socket.AF_INET, socket.SOCK_STREAM) as s:
            s = connect_socket (s, server_ip, server_port, self.logger)
            if s == None:
                return
            while True:
                print ("Options:\n1. Request photo\n2. Exit")
                option = input("Enter your choice: ").strip()

                if option == "1":
                    try:
                        s.sendall ("TAKE_PHOTO".encode ('utf-8'))
                        sleep(5)

                        success, image_path = self.receive_photo(s)
                        if success:
                            self.logger.info (f"Photo received and saved as {image_path}")
                        else:
                            self.logger.info ("Failed to receive complete photo")
                        continue
                    except Exception as e:
                        print (f"Error during photo request: {e}")

                elif option == "2":
                    self.logger.info ('Exiting')
                    s.close()
                    break
                else:
                    print("Invalid option. Please try again.")


if __name__ == "__main__":
    client = PhotoClient()
    
    # Please confirm that you have the right server IP address
    client.update_server_ip()
    client.interactive_client_session()
