import os
import sys
import socket
import yaml 
import threading
import logging  # Temporary for simple logger
from datetime import datetime
from pathlib import Path

# Add system packages path for picamera2 and libcamera (confirmed location from diagnostic)
sys.path.insert(0, '/usr/lib/python3/dist-packages')

from picamera2 import Picamera2
from libcamera import controls, Transform
from time import sleep

# ORIGINAL SDL_UTILS IMPORT (commented out temporarily)
# from sdl_utils import get_logger, send_file_name, receive_file_name, send_file_size, send_file_name, receive_file_name, receive_file_size

# ============================================================================
# TEMPORARY REPLACEMENT FUNCTIONS (remove when sdl_utils is working)
# ============================================================================

# Simple logging setup (replacing sdl_utils.get_logger)
def get_logger(name):
    logger = logging.getLogger(name)
    logger.setLevel(logging.INFO)
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
    return logger

# Simple file transfer functions (replacing sdl_utils functions)
def send_file_name(conn, filename, logger):
    filename_bytes = filename.encode('utf-8')
    filename_length = len(filename_bytes)
    conn.sendall(filename_length.to_bytes(4, byteorder='big'))
    conn.sendall(filename_bytes)
    logger.info(f"Sent filename: {filename}")

def receive_file_name(conn, logger):
    try:
        length_bytes = conn.recv(4)
        if len(length_bytes) != 4:
            return None
        length = int.from_bytes(length_bytes, byteorder='big')
        filename_bytes = conn.recv(length)
        filename = filename_bytes.decode('utf-8')
        logger.info(f"Received filename: {filename}")
        return filename
    except Exception as e:
        logger.error(f"Error receiving filename: {e}")
        return None

def send_file_size(conn, size, logger):
    size_str = str(size)
    size_bytes = size_str.encode('utf-8')
    size_length = len(size_bytes)
    conn.sendall(size_length.to_bytes(4, byteorder='big'))
    conn.sendall(size_bytes)
    logger.info(f"Sent file size: {size}")

def receive_file_size(conn, logger):
    try:
        length_bytes = conn.recv(4)
        if len(length_bytes) != 4:
            return None
        length = int.from_bytes(length_bytes, byteorder='big')
        size_bytes = conn.recv(length)
        size_str = size_bytes.decode('utf-8')
        logger.info(f"Received file size: {size_str}")
        return size_str
    except Exception as e:
        logger.error(f"Error receiving file size: {e}")
        return None

# ============================================================================
# END TEMPORARY REPLACEMENT FUNCTIONS
# ============================================================================


""" This code will establish a server on a Pi Zero 2W allowing it to send photos to the client """

# Get the yaml file containing the settings we need to establish a server connection

# Path(__file__): Creates a Path object pointing to this script file
# .resolve(): Converts it to an absolute path (e.g., /home/pi/camera_server.py)
# .parent: Gets the directory containing the script (e.g., /home/pi).

script_dir = Path(__file__).resolve().parent


# Opening and reading the yaml file

with open(script_dir / "server_settings.yaml", 'r') as f:

    data = yaml.safe_load(f)
    buffer_size = data["BufferSize"]
    chunk_size = data["ChunkSize"]
    server_port = data["ServerPort"]

# CameraServer class that takes allows for taking a picture using the camera on Pi and sending it to the client when requested

class CameraServer:

    # Making the host = 0.0.0.0 allows it to accept connections from multiple different interfaces, like WiFi, Ethernet etc
    def __init__ (self, host = "0.0.0.0", port = server_port):

        self.host = host
        self.port = port
        self.logger = self.setup_logger()
        self.server_ip = self.get_server_ip()
        self.cam = self.init_cam()
        self.camera_lock = threading.Lock() # Only allows one client to access the server at a time to prevent inteference
       
    # Static class method which does not depend on an instance
    # Calls the get_logger function from sdl_utils to initalize a logger called " WirelessCameraLogger"
    @staticmethod
    def setup_logger():
        return get_logger("WirelessCameraLogger")
    
    # Allows us to obtain the IP address of the Raspberry Pi
    def get_server_ip (self):

        # Uses IPv4 as the address family and UDP as type to socket to set up a dummy connection and test if the connection works
        with socket.socket (socket.AF_INET,socket.SOCK_DGRAM) as s_test:
            s_test.connect (("8.8.8.8", 80)) # Pings google 
            server_ip = s_test.getsockname()[0]
            self.logger.info (f"My IP address is: {server_ip}")
            return server_ip
        
    def init_cam(self):
        self.logger.info ("Initializing camera session")
        cam = Picamera2(0) # Connects to the first (for our case, the only) camera module the Pi encounters
        config = cam.create_still_configuration(transform = Transform(hflip = 1,vflip = 1)) # Sets a still image configuration for the camera (to take photos, not videos)
        cam.configure(config)
        # Checks if the camera has autofocus mode and enables it
        if 'AfMode' in cam.camera_controls:
            # Switch to autofocus mode for automatic focusing
            # Options: controls.AfModeEnum.Auto, controls.AfModeEnum.Continuous, controls.AfModeEnum.Manual
            cam.set_controls({"AfMode": controls.AfModeEnum.Continuous})
            self.logger.info("Camera focus set to Continuous Autofocus")
            
            # Optional: If you want to go back to manual focus, uncomment below:
            # lens_position = 400  # Adjust this value for better focus
            # cam.set_controls({"AfMode": controls.AfModeEnum.Manual, "LensPosition": lens_position})
            # self.logger.info(f"Camera focus set to Manual LensPosition: {lens_position}")
        cam.start()
        self.logger.info ("Camera initiated")
        return cam
    # Make sure that the instance of the camera object is destroyed when camera is closed
    def __del__(self):
        
        if hasattr (self, 'cam'):
            self.cam.stop()
            self.cam.close()
            self.logger.info (f"Camera closed.")
    
    # This function will instantiate a new camera instance every time and take a photo

    def take_photo (self):

        try:

            with self.camera_lock:

                # Create output directory by getting the current working directory and creating an absolute path to a subfolder named "photos" inside the cwd
                photo_dir = os.path.join (os.getcwd(), "photos")
                os.makedirs (photo_dir, exist_ok = True)

                # Generate filename
                timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
                filename = f"capture_{timestamp}.jpg"
                img_path = os.path.join (photo_dir, filename)

                # Camera operation
                sleep(3)           # Wait for auto-exposure to settle
                self.cam.capture_file (img_path)
                self.logger.info (f"Captured {filename}")
                return img_path

        except Exception as e:
            self.logger.error (f"Capture failed: {e}")
            return None
        
    """
    The function does a few things here: 
        (i) Sends the file name
        (ii) Sends the file size
        (iii) Confirms the file name 
        (iv) Confirms the file size
        (v) Sends the file
       
        Parameters used here are as follows:
        (i) param conn: Socket connection object connection between the server and client
        (ii) param img_path: Absolute image path on the server

    """

    def send_photo (self, conn, img_path):

    # Read the entire file into memory:
        with open(img_path, 'rb') as f:
            image_data = f.read()
            img_size = len (image_data)
            img_name = os.path.basename (img_path)

    # Send the file name
        send_file_name (conn, img_name, self.logger)
        self.logger.info (f"Sent file name {img_name}.")

    # Confirm echoed filename (that the file was received by the client and a confirmation was sent back)
        echo_name = receive_file_name (conn, self.logger)
        if not echo_name:
            self.logger.error ("Failed to receive echoed image name from client.")
            return False
        elif echo_name != img_name:
            self.logger.error ("File name mismatch! Aborting transfer.")
            return False
        else:
            self.logger.info (f"Client confirmed image name {img_name}.")

    # Send size
        send_file_size (conn, img_size, self.logger)
        self.logger.info (f"Sent file size {img_size} to client.")

    # Confirm echoed size
        echoed_size_str = receive_file_size(conn, self.logger)
        if not echoed_size_str:
            self.logger.error ("Failed to receive echoed size from client (connection closed).")
            return False
        try:
            echoed_size = int (echoed_size_str)
            if echoed_size != img_size:
                self.logger.error ("File size mismatch! Aborting transfer.")
                return False
            else:
                self.logger.info ("File size confirmed. Proceeding with file transfer.")
        except ValueError:
            self.logger.error (f"Invalid size echoed: '{echoed_size_str}'.")
            return False

    # Send the file data in chunks
        offset = 0
        while offset < img_size:
            end = offset + chunk_size
            chunk = image_data[offset:end]
            conn.sendall(chunk)
            offset = end
        self.logger.info("File transfer complete.")
        self.logger.info("Waiting for new command...")


# Handle client connection in a thread-safe manner

    def handle_client (self, conn):
        try:
            while True:
                msg = conn.recv(buffer_size).decode('utf-8').strip()
                if not msg:
                    break
                self.logger.info(f"Received message: {msg}.")

                if msg == "TAKE_PHOTO":
                    image_path = self.take_photo()
                    if image_path:
                        self.send_photo(conn, image_path)
                else:
                    self.logger.info (f"Unknown command received: {msg}. Closing connection.")
                    break  # Unknown command; exit loop

        except Exception as e:
            self.logger.error(f"Handle client error: {e}.")
        finally:
            conn.close()
            self.logger.info("Client connection closed.")
            self.logger.info("Waiting for new connection.")

    # Startsthe server witrh clean error handling
    def start_server(self):
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server.setsockopt (socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        try:
            self.logger.info(f"Attempting to bind to {self.host}:{self.port}...")
            server.bind((self.host, self.port))  # Use self.host (0.0.0.0) instead of self.server_ip
            self.logger.info(f"Successfully bound to {self.host}:{self.port}")
            
            self.logger.info("Starting to listen for connections...")
            server.listen(5)
            self.logger.info(f"Server started on {self.host}:{self.port} (accessible via {self.server_ip}:{self.port}).")
            self.logger.info("Waiting for connection...")

            while True:
                self.logger.info("Calling server.accept()...")
                conn, addr = server.accept()
                self.logger.info(f"Connected with address: {addr}.")
                threading.Thread(
                    target=self.handle_client,
                    args=(conn,),
                    daemon=True
                ).start()

        except KeyboardInterrupt:
            self.logger.info("Server shutdown requested.")
        except OSError as e:
            self.logger.error(f"Socket error: {e}")
            self.logger.error("This might be a port binding issue or permission problem")
        except Exception as e:
            self.logger.error(f"Unexpected server error: {e}")
            import traceback
            self.logger.error(f"Traceback: {traceback.format_exc()}")
        finally:
            server.close()
            self.logger.info("Server socket closed.")


if __name__ == "__main__":
    camera = CameraServer()
    camera.start_server()